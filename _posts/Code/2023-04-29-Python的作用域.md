---
title:	"Python作用域"
mathjax: True
layout: post
categories: Code
---

### 1. Python数据基本类型

Python中的数据有6大基本类型：数字(Number)、字符串(String)、列表(List)、元组(Tuple)、字典(Dictionary)、集合(Set)。其中数字、字符串、元组属于不可更改的数据，列表、字典、集合属于可更改的数据。

---

### 2. 赋值在Python与C中的区别

<font color=YellowGreen>（这一小节基于我的猜想，不一定准确）</font>

C中给变量赋值，需要先定义变量的数据类型，再进行赋值；而Python中变量不需要定义，可直接赋值。这导致两种语言的赋值逻辑完全不同，下面给出例子：

```c
# C++

int a;		//让指针*a指向一块内存空间，该空间用来存放一个int型变量
a = 1;		//指针*a指向的内存空间存放的数据变为1    
a = 2;		//指针*a指向的内存空间存放的数据变为2
```

```python
# Python

a = 1		#内存空间里给出一部分存放了数字型数据，值为1，然后让a指向它
a = 2		#内存空间里给出一部分存放了数字型数据，值为2，然后让a指向它
a = 'Two'	#内存空间里给出一部分存放了字符串型数据，值为’Two'，然后让a指向它
```

简单来说，<font color=red>在C语言中进行赋值('a=2')操作时，指针*a的指向不变，变的是指向位置内的数据；而在Python中进行赋值('a=2')时，a会指向新的地址。</font>

因此，对于Python来说，以下两种操作代表的意义完全不同：

```python
a = [1, 2]

# 赋值，a指向新的区域
a = [1, 2, 3]
# a指向位置不变，改变的是指向位置的数据
a.append(3)
```

---

### 3. Python变量作用域

#### 3.1 Python变量定义的时间和空间

Python是动态类型语言，变量是在定义的时候进行赋值

```python
# 赋值时定义变量a
a = 1

# 导入时定义变量cubie
from tools import cubie

# 定义变量name为函数fun的形式变量（局部变量），定义函数变量fun
def fun(name=None):

# 定义类变量Car
class Car:
```

变量的作用域取决于其定义位置

1. 局部变量(Local)：定义在函数内部的变量；定义在函数声明中的形式参数
2. 自由变量(Enclose)：定义在函数中，嵌套函数外，且被嵌套函数引用的变量
3. 全局变量(Global)：定义在.py文件内的，且函数、类之外的变量
4. 内置变量(Builtin)：定义在builtin中的变量

#### 3.2 LEGB规则

1. 四个作用域遵循LEGB规则，以下面例子来说明：

   ```python
   import builtins
    
   builtins.b = 'builtins'
   g = 'global' 
   def outer(o1,o2='o2'):
       e = 'enclose'
       def inner(i1,i2='i2'):
           print(i1,i2,o1,o2,e,g,b)
       return inner 
    
   fun = outer('o1') 
   fun('i1')
   ```

   输出结果

   ```
   i1 i2 o1 o2 enclose global builtins
   ```

   其中

   1. `i1 i2`：在本地作用域中找到，为局部变量
   2. `o1 o2 e`：本地作用域中没有，在outer函数作用域内有，为自由变量
   3. `g`：本地作用域和自由变量作用域没有，在全局作用域找到，为全局变量
   4. `b`：本地作用域、自由变量作用域和全局作用域都没有，在内置变量空间找到，为内置变量

   <font color=red>可以看到四种变量都能被找到。</font>

2. 自由变量也是可以逐层传递的，以下面例子来说明：

   ```python
   g = 'global'
   def outer2():
       e2 = 'enclose2'
       def outer():        
           e = 'enclose'
           def inner(l):
               print(l, e, e2, g)
           return inner 
       return outer
    
   fun = outer2() 
   fun2 = fun()
   fun2('local')
   ```

   输出结果

   ```
   local enclose enclose2 global
   ```

   <font color=red>可以看到enclose2作为两层外的自由变量也能被找到。</font>

#### 3.3 Nonlocal和Global

对变量有两种使用方式

1. 赋值：创建或修改一个变量
2. 引用：检索其值

在函数中，对全局变量或自由变量进行两种使用会导致不同的效果

1. 赋值：等于创建一个局部变量
2. 引用：检索其值

为了解决局部作用域中赋值全局变量和自由变量导致的变成局部变量问题，Python引入关键字 `global` 和 `nonlocal` ，用下面例子来说明：

```python
g = 'global' 
def outer():
    e = 'enclose'
    def inner(l):
        global g
        nonlocal e
        g = 'inner global'
        e = 'inner enclose'
        print(l,e,g)
    return inner 
 
fun = outer() 
fun('local') 
print(g)
```

输出结果

```
local inner enclose inner global
inner global
```

<font color=red>可以看到在添加了声明后，在函数内能直接修改全局变量和自由变量的值。</font>

### 4. Python中不做声明的变量使用或修改

#### 4.1 通过形参对变量的使用和修改

1. 3种不可更改的数据类型

   对于数字、字符串、元组三种不可更改的数据类型，函数内只能使用它们的值，无法进行更改；若试图用赋值语句进行修改，只会生成新的局域变量，无法将这个改变传递出来。

2. 3种可更改的数据类型

   对于列表、字典、集合三种可更改的数据类型，函数内可以使用它们的值，也可以对它们进行修改；但函数内无法改变其指向地址（用赋值语句只会生成新的局域变量，不会传递出去），只能改变其指向地址的内容（用.append，a[0]=1这种方式可以将修改传递出去）

   ```python
   # 赋值无法传递，输出[1,2]
   def test(form_para):
       form_para = [3, 4]
   
   actu_para = [1, 2]
   test(actu_para)
   print(actu_para)
   
   # 指向地址的内容可以改变，输出[1,2,3]
   def test(form_para):
       form_para.append(3)
   
   actu_para = [1, 2]
   test(actu_para)
   print(actu_para)
   ```

#### 4.2 直接跨域对变量的使用和修改

Python中直接跨域使用变量时，对变量的处理方式和通过形参基本一致，即可以使用它们的值，也可以改变它们指向的内存空间的内容，但不能直接更改它们的指向（用赋值语句只会生成新的局域变量，不会传递出去）。但两种方式有个区别，就是形参使用时，可以先对数据引用(b=a)或修改(a.append)，然后赋值(a=1，会生成新的局域变量a)，但在直接跨域使用时这种情况会报错。

用下面例子来说明：

```python
# 不传递参数 输出2，1
def fun():
    a = 2
    print(a)
    
a = 1
fun()
print(a)
```

```python
# 传递参数 输出1，1
def fun():
    b = a
    print(b)
    
a = 1
fun()
print(a)
```

```python
# 传递参数，且修改指针指向 代码报错
def fun():
    b = a
    print(b)
    a = 2
    
a = 1
fun()
print(a)
```

```python
# 传递参数，且修改指针指向 代码报错
def fun():
    b = a
    print(b)
    a = [3, 4]
    
a = [1, 2]
fun()
print(a)
```

```python
# 传递参数，不修改指针指向，修改指针指向内存区域的数据 输出[1,2]，[1,2,3]
def fun():
    b = a
    print(b)
    a.append(3)
    
a = [1, 2]
fun()
print(a)
```

### 5. 总结

1. 在函数内调用函数外的数据有三种方式：

   1. 全局申明
   2. 形参调用
   3. 直接使用

   把对传递进来的变量`a`的操作分为三类：

   1. 引用：`b=a`
   2. 赋值：`a=1`，`a=[1,2]`
   3. 修改：`a.append(1)`，`a[0]=1`

2. <font color=red>再未进行全局申明的情况下，对于三种不能修改的数据，只能去“引用”它们的值；对于三种可以修改的数据，可以通过“修改”操作在函数内对函数外的变量进行修改，但是不能通过“赋值”操作进行修改。</font>

3. 不同操作的实现逻辑

   1. <font color=red>“引用”操作基于LEGB原则从内到外对变量名进行寻找，只要能找到就能“引用”该变量的值；</font>
   2. <font color=red>“修改”操作也是基于LEGB原则从内到外对变量名进行寻找，只要能找到就能“修改”该变量的值，且这种“修改”能够跨域进行传递；</font>
   3. <font color=red>“赋值”操作相当于修改变量的指向，一旦在函数内进行赋值，即生成该变量名对应的局域变量，此时该变量就和函数外的同名变量脱离了关系了。</font>

   <font color=red>注意在“直接使用”函数外的变量时，一旦进行了“引用”或者“修改”，就不能再进行“赋值”了（此时不会生成新的局域变量，而是直接报错）</font>

   


主要参考：

1. [Python中令人头疼的变量作用域问题，终于弄清楚了](https://blog.csdn.net/fengdu78/article/details/116617923)
1. [ 3分钟弄懂python函数传参是否改变外部变量的值](https://blog.csdn.net/weixin_42143579/article/details/109011604)
